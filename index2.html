<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>éŸ³ã®ãƒ‡ã‚¸ã‚¿ãƒ«åŒ–ä½“é¨“ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ï¼†éŒ²éŸ³ï¼‰</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/addons/p5.sound.min.js"></script>
    <style>
      #dropZone {
        border: 2px dashed #ccc;
        border-radius: 10px;
        padding: 30px;
        margin-bottom: 20px;
        text-align: center;
        transition: background-color 0.3s;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <main style="text-align:center;">
      <h2>ğŸ™ï¸ éŸ³ã®ãƒ‡ã‚¸ã‚¿ãƒ«åŒ–ä½“é¨“</h2>
      <p>éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã‹ã€**ãƒã‚¤ã‚¯ã§éŒ²éŸ³**ã—ã¦ã€æ¨™æœ¬åŒ–ã¨é‡å­åŒ–ã®å½±éŸ¿ã‚’ä½“é¨“ã—ã‚ˆã†ã€‚</p>

      <div id="dropZone" ondragover="return false;">
        ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã“ã“ã«ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ã€ã¾ãŸã¯<br />
        <label for="fileInput" style="color: blue; text-decoration: underline;">ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</label>
        <input type="file" id="fileInput" accept="audio/*" style="display: none;" />
      </div>

      <button id="recordStartBtn">ğŸ™ï¸ éŒ²éŸ³é–‹å§‹</button>
      <button id="recordStopBtn" disabled>â–  éŒ²éŸ³åœæ­¢</button>
      
      <span id="fileStatus" style="color:blue; display:block; margin-top:10px;">éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„</span><br />

      <button id="processBtn" disabled>âš™ï¸ å‡¦ç†ï¼†å†ç”Ÿ</button>
      <button id="stopBtn" disabled>â–  å†ç”Ÿã‚’åœæ­¢</button><br /><br />
      
      <label>å…ƒã®éŸ³å£°å†ç”Ÿ:</label>
      <audio id="playback" controls disabled></audio><br /><br />

      <label>æ¨™æœ¬åŒ–ãƒ¬ãƒ¼ãƒˆï¼ˆä½ãƒ¬ãƒ¼ãƒˆ â† **é«˜éŸ³è³ª** â†’ é«˜ãƒ¬ãƒ¼ãƒˆï¼‰ï¼š</label>
      <input type="range" id="sampleSlider" min="1" max="50" value="50" /> 
      <span id="sampleValue"></span><br />

      <label>é‡å­åŒ–ãƒ“ãƒƒãƒˆæ•°ï¼ˆ2 bit â† **é«˜éŸ³è³ª** â†’ 24 bitï¼‰ï¼š</label>
      <input type="range" id="bitSlider" min="2" max="24" value="8" />
      <span id="bitValue"></span><br /><br />

      <div id="waveContainer" style="margin-top:20px;">
        <h4>æ³¢å½¢è¡¨ç¤º</h4>
      </div>
    </main>

    <script>
      let recordedBuffer = null; 
      let processedBuffer = null; 
      let waveform = []; 
      let currentSource = null; 
      let audioContext = null; 
      let startTime = 0; 
      
      let mediaRecorder;
      let audioChunks = [];
      let currentStream; 

      const BASE_SAMPLE_RATE = 44100;
      const MAX_STEP = 50;
      const FIXED_GAIN = 4.0; 
      let MIME_TYPE = 'audio/webm; codecs=opus'; // ãƒ–ãƒ©ã‚¦ã‚¶äº’æ›æ€§ã®é«˜ã„å½¢å¼

      function getAudioContext() {
          if (!audioContext) {
              audioContext = new (window.AudioContext || window.webkitAudioContext)();
          }
          // ã€ä¿®æ­£1ã€‘AudioContextãŒåœæ­¢çŠ¶æ…‹ã®å ´åˆã€å¼·åˆ¶çš„ã«å†é–‹ã‚’è©¦ã¿ã‚‹
          if (audioContext.state === 'suspended') {
              audioContext.resume().catch(e => console.error("AudioContext resume failed:", e));
          }
          return audioContext;
      }

      function calculateSampleStep(sliderValue) {
          const normalized = (sliderValue - 1) / (MAX_STEP - 1);
          const reverseNormalized = 1 - normalized; 
          const minStep = 1;
          const logMin = Math.log(minStep);
          const logMax = Math.log(MAX_STEP);
          const logStep = logMin + (logMax - logMin) * reverseNormalized;
          const sampleStep = Math.round(Math.exp(logStep));
          return Math.max(minStep, sampleStep); 
      }

      function updateSampleRateDisplay() {
        const sliderValue = int(select("#sampleSlider").value());
        const sampleStep = calculateSampleStep(sliderValue); 
        const currentRate = BASE_SAMPLE_RATE / sampleStep;
        
        let rateText;
        if (currentRate >= 1000) {
          rateText = (currentRate / 1000).toFixed(1) + " kHz";
        } else {
          rateText = currentRate.toFixed(0) + " Hz";
        }

        const minRate = (BASE_SAMPLE_RATE / MAX_STEP).toFixed(0);
        select("#sampleValue").html(`${rateText} (ç¯„å›²: ${minRate} Hz ã€œ 44.1 kHz)`);
      }

      function updateBitDepthDisplay() {
        select("#bitValue").html(`${select("#bitSlider").value()} bit`);
      }

      function stopCurrentPlayback() {
          if (currentSource) {
              try {
                  currentSource.stop();
              } catch (e) {
                  // ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
              } finally {
                  currentSource = null;
              }
          }
          select("#stopBtn").attribute("disabled", "true");
          
          if (recordedBuffer) {
              const duration = recordedBuffer.duration.toFixed(2);
              select("#fileStatus").html(`âœ… èª­ã¿è¾¼ã¿å®Œäº† (${duration} ç§’)`).style("color", "green");
          } else {
              select("#fileStatus").html("éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„").style("color", "blue");
          }
          
          noLoop(); 
          if(processedBuffer) {
              drawWaveformArray(waveform, -1); 
          } else if (recordedBuffer) {
              drawWaveform(recordedBuffer, -1);
          }
      }


      function setup() {
        let cnv = createCanvas(600, 400); 
        cnv.parent("waveContainer");
        background(240);
        textAlign(CENTER);
        text("ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€ã¨æ³¢å½¢ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™", width / 2, height / 2);

        noLoop(); 
        
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
        select("#processBtn").mousePressed(processAndPlay);
        select("#stopBtn").mousePressed(stopCurrentPlayback); 
        select("#sampleSlider").input(updateSampleRateDisplay);
        select("#bitSlider").input(updateBitDepthDisplay);
        
        // éŒ²éŸ³ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        select("#recordStartBtn").mousePressed(startRecording);
        select("#recordStopBtn").mousePressed(stopRecording);

        updateSampleRateDisplay(); 
        updateBitDepthDisplay();
        
        const fileInput = select("#fileInput");
        const dropZone = select("#dropZone");
        fileInput.changed(handleFileSelect);
        
        dropZone.dragOver(() => {
            dropZone.style("background-color", "#f0f0ff");
            return false;
        });
        dropZone.dragLeave(() => {
            dropZone.style("background-color", "#fff");
        });
        dropZone.drop(handleFileDrop);

        // æœ€åˆã®ã‚¯ãƒªãƒƒã‚¯ã§AudioContextã‚’å†é–‹ã™ã‚‹å‡¦ç†ï¼ˆãƒ¢ãƒã‚¤ãƒ«å¯¾ç­–ï¼‰
        document.addEventListener('click', () => {
          getAudioContext();
        }, { once: true });
      }
      
      // ã€ä¿®æ­£2ã€‘MediaRecorderã«MIMEã‚¿ã‚¤ãƒ—ã‚’æ˜ç¤ºçš„ã«æŒ‡å®š
      async function startRecording() {
          stopCurrentPlayback(); 
          audioChunks = [];

          // äº’æ›æ€§ãƒã‚§ãƒƒã‚¯
          if (MediaRecorder.isTypeSupported('audio/webm; codecs=opus')) {
              MIME_TYPE = 'audio/webm; codecs=opus';
          } else if (MediaRecorder.isTypeSupported('audio/mp4')) {
              MIME_TYPE = 'audio/mp4'; // Safariå¯¾ç­–
          } else if (MediaRecorder.isTypeSupported('audio/wav')) {
              MIME_TYPE = 'audio/wav'; 
          } else {
              MIME_TYPE = ''; // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
          }


          try {
              // ãƒã‚¤ã‚¯ã‚¢ã‚¯ã‚»ã‚¹ã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
              currentStream = await navigator.mediaDevices.getUserMedia({ audio: true });
              
              // MIMEã‚¿ã‚¤ãƒ—ã‚’æŒ‡å®šã—ã¦MediaRecorderã‚’åˆæœŸåŒ–
              mediaRecorder = new MediaRecorder(currentStream, { mimeType: MIME_TYPE });
              
              mediaRecorder.ondataavailable = event => {
                  if (event.data.size > 0) {
                      audioChunks.push(event.data);
                  }
              };

              mediaRecorder.onstop = () => {
                  handleRecordedData();
              };

              mediaRecorder.start();
              
              select("#recordStartBtn").attribute("disabled", "true");
              select("#recordStopBtn").removeAttribute("disabled");
              select("#fileStatus").html("ğŸ”´ éŒ²éŸ³ä¸­... ãƒã‚¤ã‚¯ã«å‘ã‹ã£ã¦è©±ã—ã¦ãã ã•ã„").style("color", "red");
              select("#processBtn").attribute("disabled", "true");

          } catch (err) {
              select("#fileStatus").html(`âŒ ãƒã‚¤ã‚¯ã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼: ${err.name} - ${err.message}`).style("color", "red");
          }
      }

      function stopRecording() {
          if (mediaRecorder && mediaRecorder.state !== "inactive") {
              mediaRecorder.stop();
              
              currentStream.getTracks().forEach(track => track.stop());
              
              select("#recordStartBtn").removeAttribute("disabled");
              select("#recordStopBtn").attribute("disabled", "true");
              select("#fileStatus").html("ğŸ’¾ éŒ²éŸ³ãƒ‡ãƒ¼ã‚¿å‡¦ç†ä¸­... ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„").style("color", "blue");
          }
      }
      
      async function handleRecordedData() {
          if (audioChunks.length === 0) {
              select("#fileStatus").html("âŒ éŒ²éŸ³ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚").style("color", "red");
              return;
          }

          // Blobã‚¿ã‚¤ãƒ—ã‚’æ˜ç¤ºçš„ã«æŒ‡å®šã™ã‚‹
          const audioBlob = new Blob(audioChunks, { type: MIME_TYPE });
          
          const arrayBuffer = await audioBlob.arrayBuffer();
          const ctx = getAudioContext();
          
          try {
              // AudioContextã®å‡¦ç†ãŒå¤±æ•—ã—ãªã„ã‚ˆã†ã«ã€ã“ã“ã§å†é–‹ã‚’è©¦ã¿ã‚‹ï¼ˆå†—é•·ã ãŒé‡è¦ï¼‰
              await ctx.resume();
              
              recordedBuffer = await ctx.decodeAudioData(arrayBuffer);
              processedBuffer = null;
              
              // å†ç”Ÿãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
              const playback = select("#playback");
              playback.attribute("src", URL.createObjectURL(audioBlob)); 
              playback.removeAttribute("disabled");

              const duration = recordedBuffer.duration.toFixed(2);
              select("#fileStatus").html(`âœ… éŒ²éŸ³å®Œäº† (${duration} ç§’)`).style("color", "green");
              
              drawWaveform(recordedBuffer);
              select("#processBtn").removeAttribute("disabled");

          } catch (e) {
              console.error("Decode Audio Data Error:", e);
              select("#fileStatus").html(`âŒ éŒ²éŸ³ãƒ‡ãƒ¼ã‚¿ã®ãƒ‡ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${e.message}ã€‚ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãŒå¯¾å¿œã—ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚`).style("color", "red");
              recordedBuffer = null;
          }
      }

      
      function handleFileDrop(event) {
          event.preventDefault(); 
          select("#dropZone").style("background-color", "#fff");
          const files = event.dataTransfer.files;
          if (files.length > 0) {
              handleFile(files[0]);
          }
      }

      function handleFileSelect() {
          const file = this.elt.files[0];
          if (file) {
              handleFile(file);
          }
      }

      async function handleFile(file) {
          stopCurrentPlayback(); 
          
          if (!file.type.startsWith("audio/")) {
              select("#fileStatus").html("âŒ ç„¡åŠ¹ãªãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™ã€‚éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚").style("color", "red");
              return;
          }

          select("#fileStatus").html(`ğŸµ ${file.name} ã‚’èª­ã¿è¾¼ã¿ä¸­...`).style("color", "blue");
          select("#processBtn").attribute("disabled", "true");
          const playback = select("#playback");
          playback.attribute("disabled", "true");
          playback.attribute("src", "");

          try {
              const arrayBuffer = await file.arrayBuffer();
              const ctx = getAudioContext();
              await ctx.resume(); // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‡ã‚³ãƒ¼ãƒ‰å‰ã«ã‚‚å†é–‹ã‚’è©¦ã¿ã‚‹
              recordedBuffer = await ctx.decodeAudioData(arrayBuffer);
              processedBuffer = null;

              const duration = recordedBuffer.duration.toFixed(2);
              select("#fileStatus").html(`âœ… èª­ã¿è¾¼ã¿å®Œäº† (${duration} ç§’)`).style("color", "green");
              
              playback.attribute("src", URL.createObjectURL(file)); 
              playback.removeAttribute("disabled");
              
              drawWaveform(recordedBuffer);
              select("#processBtn").removeAttribute("disabled");

          } catch (e) {
              select("#fileStatus").html(`âŒ ãƒ‡ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${e.message}`).style("color", "red");
              recordedBuffer = null;
              processedBuffer = null;
              drawWaveform(null);
          }
      }


      function drawWaveform(buffer) {
        background(255); 
        
        if (!buffer) {
          text("ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„", width / 2, height / 2);
          return;
        }
        
        const data = buffer.getChannelData(0);
        waveform = []; 
        const step = Math.floor(data.length / width); 
        for (let i = 0; i < data.length; i += step) {
          waveform.push(data[i]);
        }
        
        drawWaveformArray(waveform, -1); 
      }

      function drawWaveformArray(arr, highlightIndex) {
        const FIXED_GAIN = 4.0; 
        const displayScale = 1.5; 

        stroke(0);
        strokeWeight(1.5);
        noFill();
        beginShape();

        for (let x = 0; x < arr.length; x++) {
          let val = constrain(arr[x] * FIXED_GAIN * displayScale, -1, 1);
          const y = height / 2 - val * (height / 2);
          vertex(x, y);
        }
        endShape();

        stroke(200);
        line(0, height / 2, width, height / 2);

        if (highlightIndex >= 0) {
          stroke(255, 0, 0);
          strokeWeight(2);
          line(highlightIndex, 0, highlightIndex, height);
          strokeWeight(1);
        }
      }

      function processAndPlay() {
        if (!recordedBuffer) return alert("éŸ³å£°ãƒ‡ãƒ¼ã‚¿ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚");
        
        stopCurrentPlayback(); 

        const sliderValue = int(select("#sampleSlider").value());
        const sampleStep = calculateSampleStep(sliderValue); 

        const bitDepth = int(select("#bitSlider").value());
        const ctx = getAudioContext();

        const numChannels = recordedBuffer.numberOfChannels;
        const length = recordedBuffer.length;
        const sampleRate = recordedBuffer.sampleRate;
        const newBuffer = ctx.createBuffer(numChannels, length, sampleRate);

        for (let ch = 0; ch < numChannels; ch++) {
          const input = recordedBuffer.getChannelData(ch);
          const output = newBuffer.getChannelData(ch);
          
          let lastValue = 0;

          for (let i = 0; i < length; i++) {
            if (i % sampleStep === 0) {
              const quantLevels = Math.pow(2, bitDepth);
              const scale = quantLevels / 2;
              lastValue = Math.round(input[i] * scale) / scale;
              output[i] = lastValue;

            } else {
              output[i] = lastValue; 
            }
          }
        }
        
        processedBuffer = newBuffer;

        drawWaveform(processedBuffer); 
        
        const src = ctx.createBufferSource();
        src.buffer = processedBuffer;
        src.connect(ctx.destination);
        
        startTime = ctx.currentTime;
        src.start(0); 
        
        currentSource = src;
        select("#stopBtn").removeAttribute("disabled");
        select("#fileStatus").html("å‡¦ç†å¾Œã®éŸ³ã‚’å†ç”Ÿä¸­...").style("color", "darkorange");
        
        loop(); 

        src.onended = () => {
            if (currentSource === src) {
                stopCurrentPlayback(); 
            }
        };
      }

      function draw() {
        if (!currentSource || !processedBuffer) {
            noLoop(); 
            return;
        }
        
        background(255); 

        const ctx = getAudioContext();
        const elapsedTime = ctx.currentTime - startTime;
        
        const totalDuration = processedBuffer.duration;
        
        if (elapsedTime >= totalDuration) {
             stopCurrentPlayback();
             return;
        }

        let currentIndex = map(elapsedTime, 0, totalDuration, 0, width);
        
        drawWaveformArray(waveform, currentIndex);
      }
    </script>
  </body>
</html>
