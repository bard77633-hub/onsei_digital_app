<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>éŸ³ã®ãƒ‡ã‚¸ã‚¿ãƒ«åŒ–ä½“é¨“ï¼ˆéŒ²éŸ³ï¼‹æ³¢å½¢è¡¨ç¤ºï¼‰</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/addons/p5.sound.min.js"></script>
  </head>
  <body>
    <main style="text-align:center;">
      <h2>ğŸ™ï¸ éŸ³ã®ãƒ‡ã‚¸ã‚¿ãƒ«åŒ–ä½“é¨“ï¼ˆp5.jsç‰ˆï¼‰</h2>
      <p>éŒ²éŸ³ã¾ãŸã¯ã‚µãƒ³ãƒ—ãƒ«éŸ³ã‚’ä½¿ã£ã¦ã€æ¨™æœ¬åŒ–ãƒ»é‡å­åŒ–ã«ã‚ˆã‚‹éŸ³è³ªå¤‰åŒ–ã‚’ä½“é¨“ã—ã‚ˆã†ã€‚</p>

      <button id="recordBtn">ğŸ§ éŒ²éŸ³é–‹å§‹</button>
      <button id="playSampleBtn">â–¶ ã‚µãƒ³ãƒ—ãƒ«éŸ³å†ç”Ÿ</button>
      <button id="processBtn" disabled>âš™ï¸ å‡¦ç†ï¼†å†ç”Ÿ</button>
      <br /><br />

      <label>æ¨™æœ¬åŒ–é–“éš”ï¼š</label>
      <input type="range" id="sampleSlider" min="1" max="20" value="1" />
      <span id="sampleValue">1</span><br />

      <label>é‡å­åŒ–ãƒ“ãƒƒãƒˆæ•°ï¼š</label>
      <input type="range" id="bitSlider" min="2" max="16" value="8" />
      <span id="bitValue">8</span><br /><br />

      <audio id="playback" controls></audio>

      <div id="waveContainer" style="margin-top:20px;">
        <h4>æ³¢å½¢è¡¨ç¤º</h4>
      </div>
    </main>

    <script>
      let micStream;
      let mediaRecorder;
      let chunks = [];
      let recordedBuffer;
      let waveform = [];
      let playing = false;

      let sampleSlider, bitSlider;
      let cnv;

      function setup() {
        cnv = createCanvas(600, 200);
        cnv.parent("waveContainer");
        background(240);
        textAlign(CENTER);
        text("éŒ²éŸ³ã¾ãŸã¯ã‚µãƒ³ãƒ—ãƒ«å†ç”Ÿå¾Œã€æ³¢å½¢ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™", width / 2, height / 2);

        sampleSlider = select("#sampleSlider");
        bitSlider = select("#bitSlider");

        select("#sampleSlider").input(() =>
          select("#sampleValue").html(sampleSlider.value())
        );
        select("#bitSlider").input(() =>
          select("#bitValue").html(bitSlider.value())
        );

        select("#recordBtn").mousePressed(toggleRecording);
        select("#playSampleBtn").mousePressed(playSample);
        select("#processBtn").mousePressed(processAndPlay);
      }

      async function toggleRecording() {
        const btn = select("#recordBtn");

        if (!mediaRecorder || mediaRecorder.state === "inactive") {
          try {
            micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(micStream);
            chunks = [];
            mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
            mediaRecorder.onstop = async () => {
              const blob = new Blob(chunks, { type: "audio/webm" });
              const arrayBuffer = await blob.arrayBuffer();
              const ctx = getAudioContext();
              recordedBuffer = await ctx.decodeAudioData(arrayBuffer);
              drawWaveform(recordedBuffer);
              select("#processBtn").removeAttribute("disabled");
            };
            mediaRecorder.start();
            btn.html("â¹ï¸ éŒ²éŸ³åœæ­¢");
          } catch (e) {
            alert("ãƒã‚¤ã‚¯ã®ä½¿ç”¨ãŒè¨±å¯ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚HTTPSã§ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
          }
        } else {
          mediaRecorder.stop();
          micStream.getTracks().forEach((t) => t.stop());
          btn.html("ğŸ§ éŒ²éŸ³é–‹å§‹");
        }
      }

      function playSample() {
        const ctx = getAudioContext();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        gain.gain.value = 0.2;
        osc.type = "sine";
        osc.frequency.value = 440;
        osc.connect(gain).connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + 1.0);

        // ã‚µãƒ³ãƒ—ãƒ«æ³¢å½¢ã‚’æç”»
        waveform = [];
        for (let i = 0; i < 600; i++) {
          waveform.push(Math.sin((i / 600) * TWO_PI * 10));
        }
        drawWaveformArray(waveform);
      }

      function drawWaveform(buffer) {
        const data = buffer.getChannelData(0);
        waveform = [];
        const step = Math.floor(data.length / width);
        for (let i = 0; i < data.length; i += step) {
          waveform.push(data[i]);
        }
        drawWaveformArray(waveform);
      }

      function drawWaveformArray(arr) {
        background(255);
        stroke(0);
        noFill();
        beginShape();
        for (let x = 0; x < arr.length; x++) {
          const y = map(arr[x], -1, 1, height, 0);
          vertex(x, y);
        }
        endShape();
      }

      function processAndPlay() {
        if (!recordedBuffer) return;

        const sampleStep = int(sampleSlider.value());
        const bitDepth = int(bitSlider.value());

        const ctx = getAudioContext();
        const numChannels = recordedBuffer.numberOfChannels;
        const length = recordedBuffer.length;
        const sampleRate = recordedBuffer.sampleRate;
        const newBuffer = ctx.createBuffer(numChannels, length, sampleRate);

        for (let ch = 0; ch < numChannels; ch++) {
          const input = recordedBuffer.getChannelData(ch);
          const output = newBuffer.getChannelData(ch);
          for (let i = 0; i < length; i++) {
            if (i % sampleStep === 0) {
              const quant = Math.pow(2, bitDepth);
              output[i] = Math.round(input[i] * (quant / 2)) / (quant / 2);
            } else {
              output[i] = output[i - 1] || 0;
            }
          }
        }

        drawWaveform(newBuffer);

        const source = ctx.createBufferSource();
        source.buffer = newBuffer;
        source.connect(ctx.destination);
        source.start();
      }

      function draw() {}
    </script>
  </body>
</html>
