<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>éŸ³ã®ãƒ‡ã‚¸ã‚¿ãƒ«åŒ–ä½“é¨“ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ï¼‰</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/addons/p5.sound.min.js"></script>
    <style>
      #dropZone {
        border: 2px dashed #ccc;
        border-radius: 10px;
        padding: 30px;
        margin-bottom: 20px;
        text-align: center;
        transition: background-color 0.3s;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <main style="text-align:center;">
      <h2>ğŸ™ï¸ éŸ³ã®ãƒ‡ã‚¸ã‚¿ãƒ«åŒ–ä½“é¨“</h2>
      <p>éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ã€æ¨™æœ¬åŒ–ã¨é‡å­åŒ–ã®å½±éŸ¿ã‚’ä½“é¨“ã—ã‚ˆã†ã€‚</p>

      <div id="dropZone" ondragover="return false;">
        ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã“ã“ã«ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ã€ã¾ãŸã¯<br />
        <label for="fileInput" style="color: blue; text-decoration: underline;">ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</label>
        <input type="file" id="fileInput" accept="audio/*" style="display: none;" />
      </div>
      <span id="fileStatus" style="color:blue;">éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„</span><br /><br />

      <button id="processBtn" disabled>âš™ï¸ å‡¦ç†ï¼†å†ç”Ÿ</button>
      <button id="stopBtn" disabled>â–  å†ç”Ÿã‚’åœæ­¢</button><br /><br />
      
      <label>å…ƒã®éŸ³å£°å†ç”Ÿ:</label>
      <audio id="playback" controls disabled></audio><br /><br />

      <label>æ¨™æœ¬åŒ–ãƒ¬ãƒ¼ãƒˆï¼ˆä½ãƒ¬ãƒ¼ãƒˆ â† **é«˜éŸ³è³ª** â†’ é«˜ãƒ¬ãƒ¼ãƒˆï¼‰ï¼š</label>
      <input type="range" id="sampleSlider" min="1" max="50" value="50" /> 
      <span id="sampleValue"></span><br />

      <label>é‡å­åŒ–ãƒ“ãƒƒãƒˆæ•°ï¼ˆ2 bit â† **é«˜éŸ³è³ª** â†’ 24 bitï¼‰ï¼š</label>
      <input type="range" id="bitSlider" min="2" max="24" value="8" />
      <span id="bitValue"></span><br /><br />

      <div id="waveContainer" style="margin-top:20px;">
        <h4>æ³¢å½¢è¡¨ç¤º</h4>
      </div>
    </main>

    <script>
      let recordedBuffer = null; 
      let waveform = [];
      let currentSource = null; 
      const BASE_SAMPLE_RATE = 44100; // åŸºæº–ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆï¼ˆHzï¼‰
      const MAX_STEP = 50; // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®æœ€å¤§ã‚¹ãƒ†ãƒƒãƒ—æ•°

      // æ¨™æœ¬åŒ–ã‚¹ãƒ†ãƒƒãƒ—ã‚’å¯¾æ•°ã‚¹ã‚±ãƒ¼ãƒ«ã§è¨ˆç®—ã™ã‚‹é–¢æ•°
      function calculateSampleStep(sliderValue) {
          const sliderMin = 1;
          const sliderMax = 50;
          
          const normalized = (sliderValue - sliderMin) / (sliderMax - sliderMin);
          const reverseNormalized = 1 - normalized; 

          const minStep = 1;
          const maxStep = MAX_STEP;

          const logMin = Math.log(minStep);
          const logMax = Math.log(maxStep);
          
          const logStep = logMin + (logMax - logMin) * reverseNormalized;

          const sampleStep = Math.round(Math.exp(logStep));
          
          return Math.max(minStep, sampleStep); 
      }

      // ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆè¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
      function updateSampleRateDisplay() {
        const sliderValue = int(select("#sampleSlider").value());
        const sampleStep = calculateSampleStep(sliderValue); 
        
        const currentRate = BASE_SAMPLE_RATE / sampleStep;
        
        let rateText;
        if (currentRate >= 1000) {
          rateText = (currentRate / 1000).toFixed(1) + " kHz";
        } else {
          rateText = currentRate.toFixed(0) + " Hz";
        }

        const minRate = (BASE_SAMPLE_RATE / MAX_STEP).toFixed(0);
        select("#sampleValue").html(`${rateText} (ç¯„å›²: ${minRate} Hz ã€œ 44.1 kHz)`);
      }

      // ãƒ“ãƒƒãƒˆæ•°è¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
      function updateBitDepthDisplay() {
        select("#bitValue").html(`${select("#bitSlider").value()} bit`);
      }

      // å†ç”Ÿãƒãƒ¼ãƒ‰ã‚’åœæ­¢ã™ã‚‹é–¢æ•°
      function stopCurrentPlayback() {
          if (currentSource) {
              try {
                  currentSource.stop();
              } catch (e) {
                  // ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
              } finally {
                  currentSource = null;
              }
          }
          select("#stopBtn").attribute("disabled", "true");
          
          if (recordedBuffer) {
              const duration = recordedBuffer.duration.toFixed(2);
              select("#fileStatus").html(`âœ… èª­ã¿è¾¼ã¿å®Œäº† (${duration} ç§’)`).style("color", "green");
          } else {
              select("#fileStatus").html("éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„").style("color", "blue");
          }
      }


      function setup() {
        // ã€ä¿®æ­£ç‚¹1: ã‚­ãƒ£ãƒ³ãƒã‚¹ã®é«˜ã•ã‚’400pxã«æ‹¡å¼µã€‘
        let cnv = createCanvas(600, 400); 
        cnv.parent("waveContainer");
        background(240);
        textAlign(CENTER);
        text("ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€ã¨æ³¢å½¢ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™", width / 2, height / 2);

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š (å¤‰æ›´ãªã—)
        select("#processBtn").mousePressed(processAndPlay);
        select("#stopBtn").mousePressed(stopCurrentPlayback); 

        select("#sampleSlider").input(updateSampleRateDisplay);
        select("#bitSlider").input(updateBitDepthDisplay);

        updateSampleRateDisplay(); 
        updateBitDepthDisplay();
        
        const fileInput = select("#fileInput");
        const dropZone = select("#dropZone");

        fileInput.changed(handleFileSelect);
        
        dropZone.dragOver(() => {
            dropZone.style("background-color", "#f0f0ff");
            return false;
        });
        dropZone.dragLeave(() => {
            dropZone.style("background-color", "#fff");
        });
        dropZone.drop(handleFileDrop);
      }
      
      function handleFileDrop(event) {
          event.preventDefault(); 
          select("#dropZone").style("background-color", "#fff");
          
          const files = event.dataTransfer.files;
          if (files.length > 0) {
              handleFile(files[0]);
          }
      }

      function handleFileSelect() {
          const file = this.elt.files[0];
          if (file) {
              handleFile(file);
          }
      }

      async function handleFile(file) {
          stopCurrentPlayback(); 
          
          if (!file.type.startsWith("audio/")) {
              select("#fileStatus").html("âŒ ç„¡åŠ¹ãªãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™ã€‚éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚").style("color", "red");
              return;
          }

          select("#fileStatus").html(`ğŸµ ${file.name} ã‚’èª­ã¿è¾¼ã¿ä¸­...`).style("color", "blue");
          select("#processBtn").attribute("disabled", "true");
          const playback = select("#playback");
          playback.attribute("disabled", "true");
          playback.attribute("src", "");

          try {
              const arrayBuffer = await file.arrayBuffer();
              const ctx = getAudioContext();
              recordedBuffer = await ctx.decodeAudioData(arrayBuffer);

              const duration = recordedBuffer.duration.toFixed(2);
              select("#fileStatus").html(`âœ… èª­ã¿è¾¼ã¿å®Œäº† (${duration} ç§’)`).style("color", "green");
              
              playback.attribute("src", URL.createObjectURL(file)); 
              playback.removeAttribute("disabled");
              
              drawWaveform(recordedBuffer);
              select("#processBtn").removeAttribute("disabled");

          } catch (e) {
              select("#fileStatus").html(`âŒ ãƒ‡ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${e.message}`).style("color", "red");
              recordedBuffer = null;
              drawWaveform(null);
          }
      }

      function drawWaveform(buffer) {
        if (!buffer) {
          background(255);
          text("ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„", width / 2, height / 2);
          return;
        }
        const data = buffer.getChannelData(0);
        waveform = [];
        const step = Math.floor(data.length / width); 
        for (let i = 0; i < data.length; i += step) {
          waveform.push(data[i]);
        }
        drawWaveformArray(waveform);
      }

      function drawWaveformArray(arr) {
        background(255);
        stroke(0);
        noFill();
        beginShape();
        for (let x = 0; x < arr.length; x++) {
          // ã€ä¿®æ­£ç‚¹2: æŒ¯å¹…ãƒãƒƒãƒ”ãƒ³ã‚°ã®èª¿æ•´ã€‘
          // æŒ¯å¹… -1 ã‹ã‚‰ 1 ã‚’ã€ã‚­ãƒ£ãƒ³ãƒã‚¹ã®é«˜ã•ï¼ˆheightï¼‰å…¨ä½“ã«ãƒãƒƒãƒ—ã™ã‚‹
          const y = map(arr[x], -1, 1, 0, height); 
          vertex(x, y);
        }
        endShape();
      }

      function processAndPlay() {
        if (!recordedBuffer) return alert("éŸ³å£°ãƒ‡ãƒ¼ã‚¿ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚");
        
        stopCurrentPlayback(); 

        const sliderValue = int(select("#sampleSlider").value());
        const sampleStep = calculateSampleStep(sliderValue); 

        const bitDepth = int(select("#bitSlider").value());
        const ctx = getAudioContext();

        const numChannels = recordedBuffer.numberOfChannels;
        const length = recordedBuffer.length;
        const sampleRate = recordedBuffer.sampleRate;
        const newBuffer = ctx.createBuffer(numChannels, length, sampleRate);

        for (let ch = 0; ch < numChannels; ch++) {
          const input = recordedBuffer.getChannelData(ch);
          const output = newBuffer.getChannelData(ch);
          
          let lastValue = 0;

          for (let i = 0; i < length; i++) {
            if (i % sampleStep === 0) {
              const quantLevels = Math.pow(2, bitDepth);
              const scale = quantLevels / 2;
              lastValue = Math.round(input[i] * scale) / scale;
              output[i] = lastValue;

            } else {
              output[i] = lastValue; 
            }
          }
        }

        drawWaveform(newBuffer);
        
        const src = ctx.createBufferSource();
        src.buffer = newBuffer;
        src.connect(ctx.destination);
        src.start(0); 
        
        currentSource = src;
        select("#stopBtn").removeAttribute("disabled");

        select("#fileStatus").html("å‡¦ç†å¾Œã®éŸ³ã‚’å†ç”Ÿä¸­...").style("color", "darkorange");
        
        src.onended = () => {
            if (currentSource === src) {
                stopCurrentPlayback(); 
            }
        };
      }

      function draw() {}
    </script>
  </body>
</html>
