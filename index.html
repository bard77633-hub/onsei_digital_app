<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>éŸ³ã®ãƒ‡ã‚¸ã‚¿ãƒ«åŒ–ä½“é¨“ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ï¼‰</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/addons/p5.sound.min.js"></script>
    <style>
      #dropZone {
        border: 2px dashed #ccc;
        border-radius: 10px;
        padding: 30px;
        margin-bottom: 20px;
        text-align: center;
        transition: background-color 0.3s;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <main style="text-align:center;">
      <h2>ğŸ™ï¸ éŸ³ã®ãƒ‡ã‚¸ã‚¿ãƒ«åŒ–ä½“é¨“</h2>
      <p>éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ã€æ¨™æœ¬åŒ–ã¨é‡å­åŒ–ã®å½±éŸ¿ã‚’ä½“é¨“ã—ã‚ˆã†ã€‚</p>

      <div id="dropZone" ondragover="return false;">
        ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã“ã“ã«ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ã€ã¾ãŸã¯<br />
        <label for="fileInput" style="color: blue; text-decoration: underline;">ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</label>
        <input type="file" id="fileInput" accept="audio/*" style="display: none;" />
      </div>
      <span id="fileStatus" style="color:blue;">éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„</span><br /><br />

      <button id="processBtn" disabled>âš™ï¸ å‡¦ç†ï¼†å†ç”Ÿ</button>
      <button id="stopBtn" disabled>â–  å†ç”Ÿã‚’åœæ­¢</button><br /><br />
      
      <label>å…ƒã®éŸ³å£°å†ç”Ÿ:</label>
      <audio id="playback" controls disabled></audio><br /><br />

      <label>æ¨™æœ¬åŒ–ãƒ¬ãƒ¼ãƒˆï¼ˆä½ãƒ¬ãƒ¼ãƒˆ â† **é«˜éŸ³è³ª** â†’ é«˜ãƒ¬ãƒ¼ãƒˆï¼‰ï¼š</label>
      <input type="range" id="sampleSlider" min="1" max="50" value="50" /> 
      <span id="sampleValue"></span><br />

      <label>é‡å­åŒ–ãƒ“ãƒƒãƒˆæ•°ï¼ˆ2 bit â† **é«˜éŸ³è³ª** â†’ 24 bitï¼‰ï¼š</label>
      <input type="range" id="bitSlider" min="2" max="24" value="8" />
      <span id="bitValue"></span><br /><br />

      <div id="waveContainer" style="margin-top:20px;">
        <h4>æ³¢å½¢è¡¨ç¤º</h4>
      </div>
    </main>

    <script>
      let recordedBuffer = null; 
      let processedBuffer = null; 
      let waveform = [];
      let currentSource = null; 
      let audioContext = null; 
      let startTime = 0; 
      
      const BASE_SAMPLE_RATE = 44100;
      const MAX_STEP = 50;

      function getAudioContext() {
          if (!audioContext) {
              audioContext = new (window.AudioContext || window.webkitAudioContext)();
          }
          return audioContext;
      }

      function calculateSampleStep(sliderValue) {
          const normalized = (sliderValue - 1) / (MAX_STEP - 1);
          const reverseNormalized = 1 - normalized; 
          const minStep = 1;
          const logMin = Math.log(minStep);
          const logMax = Math.log(MAX_STEP);
          const logStep = logMin + (logMax - logMin) * reverseNormalized;
          const sampleStep = Math.round(Math.exp(logStep));
          return Math.max(minStep, sampleStep); 
      }

      function updateSampleRateDisplay() {
        const sliderValue = int(select("#sampleSlider").value());
        const sampleStep = calculateSampleStep(sliderValue); 
        
        const currentRate = BASE_SAMPLE_RATE / sampleStep;
        
        let rateText;
        if (currentRate >= 1000) {
          rateText = (currentRate / 1000).toFixed(1) + " kHz";
        } else {
          rateText = currentRate.toFixed(0) + " Hz";
        }

        const minRate = (BASE_SAMPLE_RATE / MAX_STEP).toFixed(0);
        select("#sampleValue").html(`${rateText} (ç¯„å›²: ${minRate} Hz ã€œ 44.1 kHz)`);
      }

      function updateBitDepthDisplay() {
        select("#bitValue").html(`${select("#bitSlider").value()} bit`);
      }

      function stopCurrentPlayback() {
          if (currentSource) {
              try {
                  currentSource.stop();
              } catch (e) {
                  // ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
              } finally {
                  currentSource = null;
              }
          }
          select("#stopBtn").attribute("disabled", "true");
          
          if (recordedBuffer) {
              const duration = recordedBuffer.duration.toFixed(2);
              select("#fileStatus").html(`âœ… èª­ã¿è¾¼ã¿å®Œäº† (${duration} ç§’)`).style("color", "green");
          } else {
              select("#fileStatus").html("éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„").style("color", "blue");
          }
          
          // å†ç”Ÿåœæ­¢æ™‚ã«draw()ãƒ«ãƒ¼ãƒ—ã‚’æ­¢ã‚ã‚‹
          noLoop(); 
          // ãƒã‚¤ãƒ©ã‚¤ãƒˆãªã—ã§æ³¢å½¢ã‚’å†æç”»
          if(processedBuffer) {
              drawWaveform(processedBuffer, -1); 
          } else if (recordedBuffer) {
              drawWaveform(recordedBuffer, -1);
          }
      }


      function setup() {
        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ã‚µã‚¤ã‚ºè¨­å®š
        let cnv = createCanvas(600, 400); 
        cnv.parent("waveContainer");
        background(240);
        textAlign(CENTER);
        text("ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€ã¨æ³¢å½¢ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™", width / 2, height / 2);

        // draw()ã®è‡ªå‹•å®Ÿè¡Œã‚’åœæ­¢ï¼ˆå†ç”Ÿé–‹å§‹æ™‚ã«å†é–‹ã™ã‚‹ï¼‰
        noLoop(); 
        
        select("#processBtn").mousePressed(processAndPlay);
        select("#stopBtn").mousePressed(stopCurrentPlayback); 
        select("#sampleSlider").input(updateSampleRateDisplay);
        select("#bitSlider").input(updateBitDepthDisplay);

        updateSampleRateDisplay(); 
        updateBitDepthDisplay();
        
        const fileInput = select("#fileInput");
        const dropZone = select("#dropZone");

        fileInput.changed(handleFileSelect);
        
        dropZone.dragOver(() => {
            dropZone.style("background-color", "#f0f0ff");
            return false;
        });
        dropZone.dragLeave(() => {
            dropZone.style("background-color", "#fff");
        });
        dropZone.drop(handleFileDrop);
      }
      
      function handleFileDrop(event) {
          event.preventDefault(); 
          select("#dropZone").style("background-color", "#fff");
          const files = event.dataTransfer.files;
          if (files.length > 0) {
              handleFile(files[0]);
          }
      }

      function handleFileSelect() {
          const file = this.elt.files[0];
          if (file) {
              handleFile(file);
          }
      }

      async function handleFile(file) {
          stopCurrentPlayback(); 
          
          if (!file.type.startsWith("audio/")) {
              select("#fileStatus").html("âŒ ç„¡åŠ¹ãªãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™ã€‚éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚").style("color", "red");
              return;
          }

          select("#fileStatus").html(`ğŸµ ${file.name} ã‚’èª­ã¿è¾¼ã¿ä¸­...`).style("color", "blue");
          select("#processBtn").attribute("disabled", "true");
          const playback = select("#playback");
          playback.attribute("disabled", "true");
          playback.attribute("src", "");

          try {
              const arrayBuffer = await file.arrayBuffer();
              const ctx = getAudioContext();
              recordedBuffer = await ctx.decodeAudioData(arrayBuffer);
              processedBuffer = null;

              const duration = recordedBuffer.duration.toFixed(2);
              select("#fileStatus").html(`âœ… èª­ã¿è¾¼ã¿å®Œäº† (${duration} ç§’)`).style("color", "green");
              
              playback.attribute("src", URL.createObjectURL(file)); 
              playback.removeAttribute("disabled");
              
              drawWaveform(recordedBuffer);
              select("#processBtn").removeAttribute("disabled");

          } catch (e) {
              select("#fileStatus").html(`âŒ ãƒ‡ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${e.message}`).style("color", "red");
              recordedBuffer = null;
              processedBuffer = null;
              drawWaveform(null);
          }
      }


      function drawWaveform(buffer, highlightIndex = -1) {
        if (!buffer) {
          background(255);
          text("ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„", width / 2, height / 2);
          return;
        }
        const data = buffer.getChannelData(0);
        waveform = [];
        // å¹…600pxã«åˆã‚ã›ã¦ãƒ‡ãƒ¼ã‚¿ã‚’é–“å¼•ã
        const step = Math.floor(data.length / width); 
        for (let i = 0; i < data.length; i += step) {
          waveform.push(data[i]);
        }
        // ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ¸¡ã—ã¦æç”»
        drawWaveformArray(waveform, highlightIndex);
      }

      function drawWaveformArray(arr, highlightIndex) {
        background(255); // ã€é‡è¦ã€‘æ¯ãƒ•ãƒ¬ãƒ¼ãƒ èƒŒæ™¯ã‚’ã‚¯ãƒªã‚¢
        
        // é€šå¸¸ã®æ³¢å½¢ã‚’æç”»
        stroke(0);
        strokeWeight(1);
        noFill();
        beginShape();
        for (let x = 0; x < arr.length; x++) {
          const y = map(arr[x], -1, 1, 0, height); 
          vertex(x, y);
        }
        endShape();

        // ã€ä¿®æ­£ç‚¹ï¼šå†ç”Ÿä½ç½®ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤ºã€‘
        if (highlightIndex >= 0) {
            stroke(255, 0, 0); // èµ¤è‰²
            strokeWeight(2);
            // å‚ç›´ç·šã‚’æç”»
            line(highlightIndex, 0, highlightIndex, height);
            strokeWeight(1); // ã‚¦ã‚§ã‚¤ãƒˆã‚’å…ƒã«æˆ»ã™
        }
      }

      function processAndPlay() {
        if (!recordedBuffer) return alert("éŸ³å£°ãƒ‡ãƒ¼ã‚¿ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚");
        
        stopCurrentPlayback(); 

        const sliderValue = int(select("#sampleSlider").value());
        const sampleStep = calculateSampleStep(sliderValue); 

        const bitDepth = int(select("#bitSlider").value());
        const ctx = getAudioContext();

        // ... (å‡¦ç†ãƒ­ã‚¸ãƒƒã‚¯ã¯å¤‰æ›´ãªã—) ...
        const numChannels = recordedBuffer.numberOfChannels;
        const length = recordedBuffer.length;
        const sampleRate = recordedBuffer.sampleRate;
        const newBuffer = ctx.createBuffer(numChannels, length, sampleRate);

        for (let ch = 0; ch < numChannels; ch++) {
          const input = recordedBuffer.getChannelData(ch);
          const output = newBuffer.getChannelData(ch);
          
          let lastValue = 0;

          for (let i = 0; i < length; i++) {
            if (i % sampleStep === 0) {
              const quantLevels = Math.pow(2, bitDepth);
              const scale = quantLevels / 2;
              lastValue = Math.round(input[i] * scale) / scale;
              output[i] = lastValue;

            } else {
              output[i] = lastValue; 
            }
          }
        }
        
        processedBuffer = newBuffer;

        drawWaveform(processedBuffer); // åˆæœŸæ³¢å½¢ã‚’æç”»
        
        const src = ctx.createBufferSource();
        src.buffer = processedBuffer;
        src.connect(ctx.destination);
        
        startTime = ctx.currentTime;
        src.start(0); 
        
        currentSource = src;
        select("#stopBtn").removeAttribute("disabled");
        select("#fileStatus").html("å‡¦ç†å¾Œã®éŸ³ã‚’å†ç”Ÿä¸­...").style("color", "darkorange");
        
        // draw()ã®å®Ÿè¡Œã‚’å†é–‹
        loop();

        src.onended = () => {
            if (currentSource === src) {
                stopCurrentPlayback(); 
            }
        };
      }

      function draw() {
        if (!currentSource || !processedBuffer) {
            noLoop(); 
            return;
        }

        const ctx = getAudioContext();
        // çµŒéæ™‚é–“ (ç§’) = ç¾åœ¨æ™‚åˆ» - å†ç”Ÿé–‹å§‹æ™‚åˆ»
        const elapsedTime = ctx.currentTime - startTime;
        
        // å†ç”ŸãŒçµ‚äº†ã—ãŸã‚‰è‡ªå‹•åœæ­¢
        if (elapsedTime > processedBuffer.duration) {
             stopCurrentPlayback();
             return;
        }

        // ã‚­ãƒ£ãƒ³ãƒã‚¹å¹…ï¼ˆ600pxï¼‰ã‚’åŸºæº–ã«ã—ãŸç¾åœ¨ã®Xåº§æ¨™ã‚’è¨ˆç®—
        const totalDuration = processedBuffer.duration;
        let currentIndex = map(elapsedTime, 0, totalDuration, 0, width);
        
        // æ³¢å½¢ã‚’å†æç”»ã—ã€ç¾åœ¨ä½ç½®ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        drawWaveform(processedBuffer, currentIndex);
      }
    </script>
  </body>
</html>
