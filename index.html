<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>éŸ³ã®ãƒ‡ã‚¸ã‚¿ãƒ«åŒ–ä½“é¨“ï¼ˆéŒ²éŸ³æ™‚é–“è¡¨ç¤ºä»˜ãï¼‰</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/addons/p5.sound.min.js"></script>
  </head>
  <body>
    <main style="text-align:center;">
      <h2>ğŸ™ï¸ éŸ³ã®ãƒ‡ã‚¸ã‚¿ãƒ«åŒ–ä½“é¨“</h2>
      <p>éŒ²éŸ³ã¾ãŸã¯ã‚µãƒ³ãƒ—ãƒ«éŸ³ã‚’ä½¿ã£ã¦ã€æ¨™æœ¬åŒ–ã¨é‡å­åŒ–ã®å½±éŸ¿ã‚’ä½“é¨“ã—ã‚ˆã†ã€‚</p>

      <button id="recordBtn">ğŸ§ éŒ²éŸ³é–‹å§‹</button>
      <span id="recStatus" style="margin-left:10px; color:blue;">åœæ­¢ä¸­</span><br />
      <span id="recTime" style="color:darkred;"></span><br /><br />

      <button id="playSampleBtn">â–¶ ã‚µãƒ³ãƒ—ãƒ«éŸ³å†ç”Ÿ</button>
      <button id="processBtn" disabled>âš™ï¸ å‡¦ç†ï¼†å†ç”Ÿ</button><br /><br />
      <label>å…ƒã®éŒ²éŸ³éŸ³å£°:</label>
      <audio id="playback" controls disabled></audio><br /><br />

      <label>æ¨™æœ¬åŒ–é–“éš”ï¼š</label>
      <input type="range" id="sampleSlider" min="1" max="20" value="1" />
      <span id="sampleValue">1</span><br />

      <label>é‡å­åŒ–ãƒ“ãƒƒãƒˆæ•°ï¼š</label>
      <input type="range" id="bitSlider" min="2" max="16" value="8" />
      <span id="bitValue">8</span><br /><br />

      <div id="waveContainer" style="margin-top:20px;">
        <h4>æ³¢å½¢è¡¨ç¤º</h4>
      </div>
    </main>

    <script>
      // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’å®šç¾©
      let micStream;
      let mediaRecorder;
      let chunks = [];
      let recordedBuffer; // Web Audio APIç”¨ã®AudioBuffer
      let recordedBlob;   // <audio>ã‚¿ã‚°ç”¨ã®Blob
      let waveform = [];
      let recordStartTime = 0;
      let recordTimer;
      let p5cnv;

      function setup() {
        p5cnv = createCanvas(600, 200);
        p5cnv.parent("waveContainer");
        background(240);
        textAlign(CENTER);
        text("éŒ²éŸ³ã¾ãŸã¯ã‚µãƒ³ãƒ—ãƒ«å†ç”Ÿå¾Œã«æ³¢å½¢ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™", width / 2, height / 2);

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
        select("#recordBtn").mousePressed(toggleRecording);
        select("#playSampleBtn").mousePressed(playSample);
        select("#processBtn").mousePressed(processAndPlay);

        select("#sampleSlider").input(() =>
          select("#sampleValue").html(select("#sampleSlider").value())
        );
        select("#bitSlider").input(() =>
          select("#bitValue").html(select("#bitSlider").value())
        );
      }

      async function toggleRecording() {
        const btn = select("#recordBtn");
        const status = select("#recStatus");
        const timeDisp = select("#recTime");
        const playback = select("#playback");
        
        // æ—¢ã«éŒ²éŸ³ä¸­ã®å ´åˆ (åœæ­¢å‡¦ç†)
        if (mediaRecorder && mediaRecorder.state === "recording") {
          mediaRecorder.stop();
          micStream.getTracks().forEach((t) => t.stop());
          btn.html("ğŸ§ éŒ²éŸ³é–‹å§‹");
          status.html("åœæ­¢ä¸­");
          clearInterval(recordTimer);
          return; // åœæ­¢å‡¦ç†ãŒå®Œäº†ã—ãŸã‚‰çµ‚äº†
        }
        
        // éŒ²éŸ³é–‹å§‹å‡¦ç†
        try {
          // ãƒã‚¤ã‚¯ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å–å¾—
          micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaRecorder = new MediaRecorder(micStream);
          chunks = [];
          recordedBuffer = null;
          recordedBlob = null;
          
          playback.attribute("disabled", "true");
          playback.attribute("src", "");

          mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
          
          // éŒ²éŸ³åœæ­¢æ™‚ã®å‡¦ç†
          mediaRecorder.onstop = async () => {
            clearInterval(recordTimer);
            
            // éŒ²éŸ³ãƒ‡ãƒ¼ã‚¿ã‚’Blobã¨ã—ã¦ä¿å­˜ã—ã€<audio>ã‚¿ã‚°ã«ã‚»ãƒƒãƒˆ
            recordedBlob = new Blob(chunks, { type: "audio/webm" });
            playback.attribute("src", URL.createObjectURL(recordedBlob));
            playback.removeAttribute("disabled");

            // Web Audio APIç”¨ã«AudioBufferã«ãƒ‡ã‚³ãƒ¼ãƒ‰
            const arrayBuffer = await recordedBlob.arrayBuffer();
            const ctx = getAudioContext();
            recordedBuffer = await ctx.decodeAudioData(arrayBuffer);
            
            const duration = recordedBuffer.duration.toFixed(2);
            status.html(`éŒ²éŸ³å®Œäº† (${duration} ç§’)`);
            drawWaveform(recordedBuffer);
            select("#processBtn").removeAttribute("disabled");
          };

          // éŒ²éŸ³é–‹å§‹
          mediaRecorder.start();
          recordStartTime = window.performance.now(); // millis()ã®ä»£ã‚ã‚Šã«performance.now()ã‚’ä½¿ç”¨
          status.html("ğŸ”´ éŒ²éŸ³ä¸­...");
          btn.html("â¹ï¸ éŒ²éŸ³åœæ­¢");

          // ã‚¿ã‚¤ãƒãƒ¼å‡¦ç†
          recordTimer = setInterval(() => {
            const elapsed = ((window.performance.now() - recordStartTime) / 1000).toFixed(1);
            timeDisp.html(`éŒ²éŸ³æ™‚é–“: ${elapsed} ç§’`);
          }, 100);

        } catch (e) {
          alert("ãƒã‚¤ã‚¯ãŒè¨±å¯ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚HTTPSã§ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚ã‚¨ãƒ©ãƒ¼: " + e.message);
          status.html("âŒ ãƒã‚¤ã‚¯ä½¿ç”¨ä¸å¯");
        }
      }

      function playSample() {
        // ... (çœç•¥: playSampleé–¢æ•°ã®å†…å®¹ã¯å¤‰æ›´ãªã—ã§å‹•ä½œã™ã‚‹)
        const ctx = getAudioContext();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        gain.gain.value = 0.2;
        osc.type = "sine";
        osc.frequency.value = 440;
        osc.connect(gain).connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + 1.0);

        // ã‚µãƒ³ãƒ—ãƒ«æ³¢å½¢æç”»
        waveform = [];
        for (let i = 0; i < 600; i++) {
          waveform.push(Math.sin((i / 600) * TWO_PI * 10));
        }
        drawWaveformArray(waveform);
        select("#recStatus").html("ã‚µãƒ³ãƒ—ãƒ«å†ç”Ÿå®Œäº†");
      }

      function drawWaveform(buffer) {
        // ... (çœç•¥: drawWaveformé–¢æ•°ã®å†…å®¹ã¯å¤‰æ›´ãªã—ã§å‹•ä½œã™ã‚‹)
        if (!buffer) {
          background(255);
          text("éŒ²éŸ³ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“", width / 2, height / 2);
          return;
        }
        const data = buffer.getChannelData(0);
        waveform = [];
        const step = Math.floor(data.length / width);
        for (let i = 0; i < data.length; i += step) {
          waveform.push(data[i]);
        }
        drawWaveformArray(waveform);
      }

      function drawWaveformArray(arr) {
        // ... (çœç•¥: drawWaveformArrayé–¢æ•°ã®å†…å®¹ã¯å¤‰æ›´ãªã—ã§å‹•ä½œã™ã‚‹)
        background(255);
        stroke(0);
        noFill();
        beginShape();
        for (let x = 0; x < arr.length; x++) {
          const y = map(arr[x], -1, 1, height, 0);
          vertex(x, y);
        }
        endShape();
      }

      function processAndPlay() {
        if (!recordedBuffer) return alert("éŒ²éŸ³ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");

        const sampleStep = int(select("#sampleSlider").value());
        const bitDepth = int(select("#bitSlider").value());
        const ctx = getAudioContext();

        const numChannels = recordedBuffer.numberOfChannels;
        const length = recordedBuffer.length;
        const sampleRate = recordedBuffer.sampleRate;
        // æ–°ã—ã„AudioBufferã‚’ä½œæˆ
        const newBuffer = ctx.createBuffer(numChannels, length, sampleRate);

        for (let ch = 0; ch < numChannels; ch++) {
          const input = recordedBuffer.getChannelData(ch);
          const output = newBuffer.getChannelData(ch);
          
          // å‡¦ç†å¾Œã®é…åˆ—ã‚’ç·šå½¢è£œé–“ã§åŸ‹ã‚ã‚‹ãŸã‚ã«ã€ç¾åœ¨ã®å€¤ã‚’ä¿æŒã™ã‚‹å¤‰æ•°
          let lastValue = 0;

          for (let i = 0; i < length; i++) {
            if (i % sampleStep === 0) {
              // æ¨™æœ¬åŒ–ç‚¹ (ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°)
              
              // é‡å­åŒ– (Quantization)
              const quantLevels = Math.pow(2, bitDepth);
              const scale = quantLevels / 2;
              lastValue = Math.round(input[i] * scale) / scale;
              output[i] = lastValue;

            } else {
              // æ¨™æœ¬åŒ–ç‚¹ä»¥å¤– (ãƒ›ãƒ¼ãƒ«ãƒ‰)
              output[i] = lastValue; 
            }
          }
        }

        drawWaveform(newBuffer);
        
        // Web Audio APIã§å‡¦ç†å¾Œã®éŸ³ã‚’å†ç”Ÿ
        const src = ctx.createBufferSource();
        src.buffer = newBuffer;
        src.connect(ctx.destination);
        src.start(0); // ã™ãã«å†ç”Ÿé–‹å§‹
        
        // å†ç”Ÿã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®æ›´æ–°
        select("#recStatus").html("å‡¦ç†å¾Œã®éŸ³ã‚’å†ç”Ÿä¸­...");
        src.onended = () => {
            select("#recStatus").html("å‡¦ç†å¾Œã®éŸ³ã®å†ç”ŸãŒçµ‚äº†ã—ã¾ã—ãŸã€‚");
        };
      }

      function draw() {
        // p5ã®ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—ã€‚æ³¢å½¢ã¯ã‚¤ãƒ™ãƒ³ãƒˆãƒ‰ãƒªãƒ–ãƒ³ã§æç”»ã™ã‚‹ãŸã‚ã€ã“ã“ã§ã¯ç©ºã®ã¾ã¾ã§å•é¡Œãªã„ã€‚
      }
    </script>
  </body>
</html>
